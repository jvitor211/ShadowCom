# üîê ShadowCom - Especifica√ß√µes de Seguran√ßa

## üõ°Ô∏è Modelo de Amea√ßas

### Advers√°rios Considerados
1. **Operadoras de Telecomunica√ß√µes**: Monitoramento de tr√°fego VoIP
2. **ISPs e Redes Corporativas**: Deep Packet Inspection (DPI)
3. **Governos e Ag√™ncias**: Intercepta√ß√£o e an√°lise de metadados
4. **Atacantes Locais**: Acesso f√≠sico ao dispositivo
5. **Malware e Apps Maliciosos**: Acesso n√£o autorizado

### Dados Protegidos
- Conte√∫do das chamadas de voz
- Texto das mensagens
- Metadados de comunica√ß√£o (timestamps, IPs, dura√ß√£o)
- Identidades dos usu√°rios
- Chaves criptogr√°ficas

---

## üîí Camadas de Prote√ß√£o

### N√≠vel 1: Criptografia de Aplica√ß√£o (E2EE)

#### Protocolo de Mensagens: Double Ratchet + X3DH
```
Inicializa√ß√£o (X3DH):
‚îú‚îÄ Identity Key (IK): Curve25519 permanente
‚îú‚îÄ Signed Pre Key (SPK): Curve25519 rotacionado semanalmente
‚îú‚îÄ One-Time Pre Keys (OPK): Pool de chaves √∫nicas
‚îî‚îÄ Ephemeral Key (EK): Nova para cada sess√£o

Deriva√ß√£o da Chave Raiz:
Root Key = HKDF(
  DH(IKa, SPKb) ||
  DH(EKa, IKb) ||
  DH(EKa, SPKb) ||
  DH(EKa, OPKb)
)
```

#### Criptografia de Chamadas de Voz (SRTP)
```
SRTP Pipeline:
RTP Stream ‚Üí AES-256-GCM ‚Üí HMAC-SHA256 ‚Üí Network

Chaves SRTP:
‚îú‚îÄ Master Key: 256 bits (derivada via DTLS handshake)
‚îú‚îÄ Salt: 112 bits
‚îú‚îÄ Key Derivation Rate: A cada 2^24 pacotes
‚îî‚îÄ Rollover Counter: Prote√ß√£o replay
```

#### Gerenciamento de Chaves
```
Rota√ß√£o de Chaves:
‚îú‚îÄ Pre Keys: Renovados quando < 100 dispon√≠veis
‚îú‚îÄ Session Keys: Nova a cada mensagem (Double Ratchet)
‚îú‚îÄ SRTP Keys: Nova a cada chamada
‚îî‚îÄ Identity Keys: Rota√ß√£o manual/anual
```

---

### N√≠vel 2: Camuflagem de Rede

#### WireGuard com Ofusca√ß√£o
```
Traffic Flow:
App ‚Üí WireGuard (ChaCha20) ‚Üí Obfs4 ‚Üí TLS 1.3 (port 443) ‚Üí Internet

Obfs4 Configuration:
‚îú‚îÄ Bridge Line: obfs4 <IP>:443 <fingerprint> cert=<cert> iat-mode=0
‚îú‚îÄ IANA Cert: V√°lido e reconhecido por DPI
‚îú‚îÄ Polymorphic Handshake: Varia por conex√£o
‚îî‚îÄ Traffic Shaping: Simula HTTPS real
```

#### Prote√ß√£o contra DPI
```
Evasion Techniques:
‚îú‚îÄ TLS Mimicry: Handshake id√™ntico ao TLS real
‚îú‚îÄ Timing Obfuscation: Delays aleat√≥rios
‚îú‚îÄ Packet Size Padding: Tamanhos variados
‚îú‚îÄ Domain Fronting: CDNs leg√≠timas
‚îî‚îÄ Decoy Traffic: Requisi√ß√µes falsas paralelas
```

---

### N√≠vel 3: Prote√ß√£o de Identidade

#### Sistema de IDs An√¥nimos
```json
User Identity:
{
  "shadowId": "derived-from-public-key-hash",
  "publicKey": "curve25519-key",
  "fingerprint": "first-16-bytes-of-sha256(publicKey)",
  "displayName": "optional-non-identifying",
  "created": "timestamp",
  "verified": false
}
```

#### Autentica√ß√£o sem Dados Pessoais
```
Registration Flow:
1. Generate Curve25519 keypair locally
2. Derive ShadowID from public key
3. No email, phone, or personal data required
4. Optional: QR code for easy sharing

Verification Methods:
‚îú‚îÄ QR Code Scan: In-person verification
‚îú‚îÄ Fingerprint Compare: Voice call verification  
‚îú‚îÄ Pre-shared Secret: Secure channel establishment
‚îî‚îÄ Social Proof: Mutual contact verification
```

---

## üëÅÔ∏è Reconhecimento Facial Seguro

### Implementa√ß√£o Biom√©trica
```
Face Recognition Pipeline:
Camera ‚Üí Face Detection ‚Üí Feature Extraction ‚Üí Hash ‚Üí Compare

Security Measures:
‚îú‚îÄ Local Processing: Nunca sai do dispositivo
‚îú‚îÄ Hash Storage: Apenas hash, nunca imagem raw
‚îú‚îÄ RAM Only: Sem persist√™ncia em disco
‚îú‚îÄ Anti-Spoofing: Liveness detection
‚îî‚îÄ Multiple Checks: Valida√ß√£o cont√≠nua
```

### Protocolo de Verifica√ß√£o Cont√≠nua
```javascript
FaceVerificationProtocol {
  initialUnlock: {
    captureTime: 3000ms,
    confidenceThreshold: 0.85,
    livenessCheck: true
  },
  
  continuousVerification: {
    interval: 2000ms,
    gracePeriod: 5000ms,
    maxFailures: 2,
    autoBlur: true
  },
  
  securityFeatures: {
    antiSpoofing: true,
    multipleAngleCheck: true,
    lightingVariation: true,
    tempHashStorage: "RAM_ONLY"
  }
}
```

---

## üö® Security Watchdog - Prote√ß√£o Ativa e Cont√≠nua

### üì¶ **M√≥dulo: Security Watchdog**

> Sistema de autodefesa ativa e cont√≠nua contra sniffers, intercepta√ß√µes, ambientes comprometidos e proxy transparentes.

#### üéØ **Objetivo do Watchdog**

Proteger o ambiente de execu√ß√£o e a rede do app ShadowCom em tempo real contra:
- **Sniffers em rede local** (modo prom√≠scuo, packet capture)
- **Ataques man-in-the-middle (MITM)** (ARP spoofing, certificate hijacking)
- **Proxies maliciosos ou DPI** (corporate proxies, government surveillance)
- **Root/jailbreak/debuggers** (ambiente de desenvolvimento comprometido)
- **Ferramentas de intercepta√ß√£o** (Burp, Charles, tcpdump, Frida)

---

### üîç **Detec√ß√µes Ativas Implementadas**

#### üîé **1. Detec√ß√£o de Sniffers e Monitoramento de Rede**

```javascript
NetworkWatchdog {
  detectPromiscuousMode() {
    // Detectar interfaces em modo prom√≠scuo (quando poss√≠vel)
    // M√©todo: an√°lise de lat√™ncia de resposta ARP
    return {
      interfaces: scanNetworkInterfaces(),
      promiscuousDetected: checkPromiscuousMode(),
      suspiciousDelay: measureARPResponseTime()
    }
  },
  
  detectARPSpoofing() {
    // Escanear pacotes ARP suspeitos
    // M√©todo: m√∫ltiplas respostas ARP para mesmo IP
    return {
      duplicateARP: scanDuplicateARPResponses(),
      gatewayMACChanges: monitorGatewayMAC(),
      arpFloodDetection: detectARPFlood()
    }
  },
  
  detectPacketCapture() {
    // Detectar ferramentas de captura ativas
    return {
      tcpdumpRunning: checkRunningProcesses(['tcpdump', 'wireshark']),
      pcapInterfaces: scanPcapCapableInterfaces(),
      networkAnalysisTools: detectNetworkTools()
    }
  }
}
```

#### üîê **2. Detec√ß√£o MITM / Proxy / DPI**

```javascript
TLSWatchdog {
  certificatePinning: {
    expectedFingerprints: {
      'shadowcom.server': 'sha256:AABBCCDD...',
      'api.shadowcom.local': 'sha256:11223344...'
    },
    
    validateCertificate(hostname, certificate) {
      const actualFingerprint = sha256(certificate.publicKey);
      const expectedFingerprint = this.expectedFingerprints[hostname];
      
      if (actualFingerprint !== expectedFingerprint) {
        return {
          threat: 'CERTIFICATE_MITM',
          action: 'BLOCK_CONNECTION',
          details: { actual: actualFingerprint, expected: expectedFingerprint }
        };
      }
      return { valid: true };
    }
  },
  
  detectSSLStrip() {
    // Detectar downgrade HTTPS ‚Üí HTTP
    return {
      httpRedirects: monitorHTTPRedirects(),
      sslDowngrade: detectProtocolDowngrade(),
      unsecureConnections: scanInsecureConnections()
    }
  },
  
  detectTLSAnomaly() {
    // Detectar delay e jitter anormais
    return {
      handshakeDelay: measureTLSHandshakeTime(),
      jitterAnalysis: analyzeTLSJitter(),
      middleboxDetection: detectTLSMiddlebox()
    }
  }
}
```

#### ‚öôÔ∏è **3. Detec√ß√£o de Ambiente Comprometido**

```javascript
HostWatchdog {
  detectRootJailbreak() {
    return {
      android: {
        suBinary: checkFileExists(['/system/bin/su', '/system/xbin/su']),
        magisk: checkMagiskInstalled(),
        xposed: checkXposedFramework(),
        buildProps: checkBuildPropsModification()
      },
      ios: {
        jailbreak: checkJailbreakIndicators(),
        cydia: checkCydiaInstalled(),
        rootHelper: checkRootHelperApps()
      }
    }
  },
  
  detectDebugEnvironment() {
    return {
      debugMode: checkDeveloperOptionsEnabled(),
      adbConnected: checkADBConnection(),
      frida: detectFridaRunning(),
      xcode: checkXcodeDebugger(),
      emulator: detectEmulatorEnvironment()
    }
  },
  
  detectMaliciousApps() {
    const suspiciousApps = [
      'com.egowall.packetcapture',
      'com.guoshi.httpcanary',
      'com.proxyman.proxyman',
      'com.charlesproxy.charles',
      'burp.suite.mobile',
      'com.topjohnwu.magisk'
    ];
    
    return {
      installedThreats: scanInstalledApps(suspiciousApps),
      runningThreats: checkRunningApps(suspiciousApps),
      networkAnalysisTools: detectNetworkAnalysisApps()
    }
  }
}
```

---

### üö® **A√ß√µes Autom√°ticas por Tipo de Amea√ßa**

#### **Matriz de Resposta a Amea√ßas**

| Amea√ßa Detectada | N√≠vel | A√ß√£o Imediata | A√ß√£o Secund√°ria |
|------------------|-------|---------------|-----------------|
| **Sniffer ativo** | üî¥ CR√çTICO | Encerrar sess√£o + wipe RAM | Alertar usu√°rio + log seguro |
| **Certificado MITM** | üî¥ CR√çTICO | Bloquear conex√£o + fallback VPN | Notificar servidor + nova rota |
| **ARP Spoofing** | üî¥ CR√çTICO | Mudar para dados m√≥veis | Alertar MITM + log evento |
| **Proxy malicioso** | üü° ALTO | Ativar obfs4 + domain fronting | Tentar rota alternativa |
| **Root/Jailbreak** | üü° ALTO | Modo restrito (fun√ß√µes limitadas) | Desabilitar recursos avan√ßados |
| **App malicioso** | üü° ALTO | Bloquear visualiza√ß√£o de dados | Modo somente chamadas |
| **Debug ativo** | üü† M√âDIO | Desconectar + modo offline | Aguardar ambiente seguro |
| **DPI detectado** | üü† M√âDIO | Ativar ofusca√ß√£o m√°xima | Rotacionar servidores VPN |

#### **Implementa√ß√£o das A√ß√µes**

```javascript
SecurityActions {
  terminateSession() {
    // Encerrar sess√£o imediatamente
    this.clearRAMData();
    this.destroyEphemeralKeys();
    this.disconnectVPN();
    this.showSecurityAlert('ENVIRONMENT_COMPROMISED');
  },
  
  activateRestrictedMode() {
    // Modo de funcionalidade limitada
    this.disableMessageViewing();
    this.disableFileSharing();
    this.enableVoiceCallsOnly();
    this.increaseEncryptionLevel();
  },
  
  switchToSecureRoute() {
    // Fallback para rota segura
    this.activateObfs4();
    this.enableDomainFronting();
    this.rotateVPNServer();
    this.enableTorMode(); // se dispon√≠vel
  },
  
  logSecurityEvent(event) {
    // Log seguro em RAM apenas
    const secureLog = {
      timestamp: Date.now(),
      eventType: event.type,
      threatLevel: event.level,
      actionTaken: event.action,
      networkInfo: this.getNetworkFingerprint(),
      deviceFingerprint: this.getDeviceFingerprint()
    };
    
    // Armazenar apenas em RAM
    this.ramOnlyEventLog.push(secureLog);
    
    // Opcional: enviar via canal criptografado
    if (this.isSecureChannelAvailable()) {
      this.sendEncryptedEvent(secureLog);
    }
  }
}
```

---

### üõ°Ô∏è **Implementa√ß√£o T√©cnica**

#### **Stack Tecnol√≥gico**

```javascript
SecurityWatchdog Implementation:
‚îú‚îÄ Core Engine: React Native (TypeScript)
‚îú‚îÄ Native Bridges: Android (Kotlin) + iOS (Swift)
‚îú‚îÄ Network Detection: Custom C++ modules
‚îú‚îÄ Certificate Pinning: react-native-cert-pinner
‚îú‚îÄ Device Detection: react-native-device-info
‚îî‚îÄ Network Analysis: Custom native implementations
```

#### **M√≥dulos Recomendados**

```json
{
  "dependencies": {
    "react-native-device-info": "^10.x",
    "react-native-cert-pinner": "^1.x", 
    "react-native-network-info": "^5.x",
    "react-native-keychain": "^8.x",
    "@react-native-async-storage/async-storage": "^1.x"
  },
  "customModules": {
    "frida-detection": "Native module for Frida detection",
    "debugger-detection": "Anti-debugging techniques", 
    "emulator-check": "Virtual environment detection",
    "network-watchdog": "Real-time network monitoring",
    "arp-monitor": "ARP spoofing detection"
  }
}
```

#### **Configura√ß√£o de Sensibilidade**

```javascript
SecurityConfiguration {
  detectionLevels: {
    PARANOID: {
      arpSpoofingThreshold: 1, // 1 duplicate ARP = alert
      certificateValidation: 'STRICT',
      debuggerDetection: 'AGGRESSIVE',
      appScanInterval: 5000 // 5s
    },
    HIGH: {
      arpSpoofingThreshold: 3,
      certificateValidation: 'STANDARD',
      debuggerDetection: 'STANDARD',
      appScanInterval: 15000 // 15s
    },
    STANDARD: {
      arpSpoofingThreshold: 5,
      certificateValidation: 'RELAXED',
      debuggerDetection: 'BASIC',
      appScanInterval: 60000 // 60s
    }
  },
  
  responseActions: {
    autoTerminate: true,
    alertUser: true,
    logEvents: true,
    fallbackVPN: true,
    restrictedMode: true
  }
}
```

---

### üß™ **Logs e Auditoria de Seguran√ßa**

#### **Estrutura de Eventos de Seguran√ßa**

```json
{
  "securityEvent": {
    "id": "uuid-v4",
    "timestamp": 1693448293,
    "eventType": "mitm_detected|sniffer_found|root_detected|debug_active",
    "threatLevel": "CRITICAL|HIGH|MEDIUM|LOW",
    "detection": {
      "method": "certificate_pinning|arp_analysis|process_scan",
      "confidence": 0.95,
      "details": {
        "networkInfo": {
          "ip": "192.168.0.1",
          "networkType": "WiFi|Cellular|VPN",
          "gateway": "192.168.0.1",
          "dns": ["8.8.8.8", "1.1.1.1"]
        },
        "threatDetails": {
          "certificateFingerprint": "sha256:...",
          "suspiciousProcess": "com.burp.suite",
          "arpConflict": "192.168.0.1 -> MAC1, MAC2"
        }
      }
    },
    "response": {
      "actionTaken": "connection_terminated|restricted_mode|vpn_fallback",
      "success": true,
      "fallbackUsed": "obfs4|tor|cellular"
    },
    "environment": {
      "deviceModel": "Samsung SM-G973F",
      "osVersion": "Android 13",
      "appVersion": "1.0.0",
      "isRooted": false,
      "debugMode": false
    }
  }
}
```

#### **Pol√≠tica de Logs de Seguran√ßa**

```javascript
SecurityLogging {
  storage: {
    ramOnly: true,           // Nunca persiste em disco
    maxEvents: 100,          // M√°ximo 100 eventos em RAM
    autoRotation: true,      // Remove eventos antigos
    encryptionRequired: true // Sempre criptografado
  },
  
  transmission: {
    secureChannelOnly: true,  // Apenas via canal seguro
    batchSize: 10,           // Enviar em lotes
    retryAttempts: 3,        // 3 tentativas m√°ximo
    fallbackStorage: false   // Nunca armazenar se falhar envio
  },
  
  privacy: {
    anonymizeIPs: true,      // Hash de IPs
    noPersonalData: true,    // Sem dados pessoais
    deviceIdHashed: true,    // Device ID com hash
    locationStripped: true   // Remove dados de localiza√ß√£o
  }
}
```

---

### üîÑ **Integra√ß√£o com Sistema Principal**

#### **Inicializa√ß√£o do Watchdog**

```javascript
// App startup
class ShadowComApp {
  async initializeSecurityWatchdog() {
    this.securityWatchdog = new SecurityWatchdog({
      level: 'HIGH',
      autoResponse: true,
      callbacks: {
        onThreatDetected: this.handleSecurityThreat.bind(this),
        onEnvironmentSecure: this.handleSecureEnvironment.bind(this),
        onActionRequired: this.handleUserAction.bind(this)
      }
    });
    
    await this.securityWatchdog.start();
    
    // Verifica√ß√£o inicial
    const initialScan = await this.securityWatchdog.performFullScan();
    if (initialScan.threatsDetected.length > 0) {
      this.handleInitialThreats(initialScan.threatsDetected);
    }
  }
  
  handleSecurityThreat(threat) {
    console.log(`üö® Security threat detected: ${threat.type}`);
    
    switch(threat.level) {
      case 'CRITICAL':
        this.terminateAndAlert(threat);
        break;
      case 'HIGH':
        this.activateRestrictedMode(threat);
        break;
      case 'MEDIUM':
        this.showWarning(threat);
        break;
    }
  }
}
```

#### **Monitoramento Cont√≠nuo**

```javascript
SecurityWatchdog {
  startContinuousMonitoring() {
    // Network monitoring
    this.networkMonitor = setInterval(() => {
      this.checkNetworkThreats();
    }, 5000);
    
    // App monitoring  
    this.appMonitor = setInterval(() => {
      this.scanInstalledApps();
    }, 15000);
    
    // Environment monitoring
    this.envMonitor = setInterval(() => {
      this.checkEnvironmentIntegrity();
    }, 10000);
    
    // Certificate monitoring
    this.certMonitor = setInterval(() => {
      this.validateActiveCertificates();
    }, 30000);
  }
}
```

---

## üö® Prote√ß√µes contra Ataques

### Prote√ß√£o do Dispositivo
```
Device Security:
‚îú‚îÄ App Pinning: Prevent debugging
‚îú‚îÄ Root/Jailbreak Detection: Disable on compromised devices
‚îú‚îÄ Screen Recording Block: Prevent capture
‚îú‚îÄ Screenshot Prevention: Black screen in app switcher
‚îú‚îÄ Anti-Forensics: Secure deletion of temp files
‚îî‚îÄ Tamper Detection: Integrity checks
```

### Prote√ß√£o de Rede
```
Network Security:
‚îú‚îÄ Certificate Pinning: Prevent MITM
‚îú‚îÄ Perfect Forward Secrecy: Session isolation
‚îú‚îÄ Connection Timeout: Automatic disconnect
‚îú‚îÄ IP Rotation: Multiple exit points
‚îú‚îÄ DNS over HTTPS: Encrypted resolution
‚îî‚îÄ Tor Integration: Optional onion routing
```

### Prote√ß√£o contra An√°lise
```
Anti-Analysis:
‚îú‚îÄ Code Obfuscation: Difficult reverse engineering
‚îú‚îÄ Control Flow Flattening: Confuse static analysis
‚îú‚îÄ String Encryption: Hide sensitive constants  
‚îú‚îÄ Dead Code Injection: Mislead analysts
‚îú‚îÄ Packing: Compress and encrypt binary
‚îî‚îÄ Anti-Debug: Detect runtime analysis
```

---

## üß™ Auditoria e Testes

### Testes de Seguran√ßa Regulares
```
Security Testing Pipeline:
‚îú‚îÄ Static Analysis: SonarQube, Semgrep
‚îú‚îÄ Dynamic Analysis: OWASP ZAP, Burp Suite
‚îú‚îÄ Crypto Validation: Test vectors, known answers
‚îú‚îÄ Network Analysis: Wireshark, tcpdump
‚îú‚îÄ Penetration Testing: External security audit
‚îî‚îÄ Code Review: Multi-person approval
```

### M√©tricas de Seguran√ßa
```
Security KPIs:
‚îú‚îÄ Key Exchange Success Rate: >99.5%
‚îú‚îÄ Connection Anonymity Score: Perfect (via tests)
‚îú‚îÄ DPI Evasion Rate: >95% (multiple DPI engines)
‚îú‚îÄ Crypto Performance: <100ms key derivation
‚îú‚îÄ Memory Leakage: Zero sensitive data in dumps
‚îî‚îÄ Vulnerability Count: Zero critical, <5 medium
```

---

## üîÑ Resposta a Incidentes

### Protocolo de Compromisso
```
Incident Response:
1. Detection: Automated monitoring alerts
2. Assessment: Determine scope and impact
3. Containment: Isolate affected systems
4. Recovery: Restore service with new keys
5. Communication: Notify users via secure channel
6. Analysis: Post-mortem and improvements
```

### Recursos de Emerg√™ncia
```
Emergency Features:
‚îú‚îÄ Panic Button: Instant app wipe
‚îú‚îÄ Canary Tokens: Detect compromise
‚îú‚îÄ Remote Kill Switch: Disable compromised instances
‚îú‚îÄ Key Revocation: Invalidate compromised keys
‚îú‚îÄ Evidence Destruction: Secure deletion
‚îî‚îÄ Backup Channels: Alternative communication
```

---

## üìã Compliance e Padr√µes

### Padr√µes Seguidos
- **NIST Cryptographic Standards**: SP 800-57, FIPS 140-2
- **RFC Standards**: RFC 8446 (TLS 1.3), RFC 3711 (SRTP)
- **Signal Protocol**: Double Ratchet, X3DH
- **OWASP Mobile Top 10**: Todas as vulnerabilidades cobertas

### Documenta√ß√£o de Conformidade
```
Compliance Documentation:
‚îú‚îÄ Crypto Implementation: NIST compliance report
‚îú‚îÄ Privacy Assessment: GDPR/CCPA analysis
‚îú‚îÄ Security Architecture: Threat model document
‚îú‚îÄ Audit Reports: Third-party security audits
‚îî‚îÄ Penetration Test Results: Regular assessment reports
```

---

## ‚öôÔ∏è Configura√ß√µes de Seguran√ßa

### Configura√ß√µes Padr√£o (High Security)
```json
{
  "encryption": {
    "algorithm": "ChaCha20-Poly1305",
    "keySize": 256,
    "keyRotation": "per-message",
    "perfectForwardSecrecy": true
  },
  
  "network": {
    "vpnEnabled": true,
    "torEnabled": false,
    "obfuscation": "obfs4",
    "domainFronting": false
  },
  
  "authentication": {
    "biometricRequired": true,
    "pinRequired": true,
    "sessionTimeout": 300,
    "maxFailedAttempts": 3
  },
  
  "privacy": {
    "metadataMinimization": true,
    "messageDisappearing": 604800,
    "contactVerification": "required",
    "analyticsDisabled": true
  },
  
  "securityWatchdog": {
    "enabled": true,
    "level": "HIGH",
    "autoResponse": true,
    "continuousMonitoring": true
  }
}
```

### Configura√ß√µes de Desenvolvimento
```json
{
  "development": {
    "debugMode": false,
    "loggingEnabled": false,
    "testKeys": false,
    "skipVerification": false,
    "allowInsecureConnections": false,
    "securityWatchdogDisabled": false
  }
}
```

---

*Esta especifica√ß√£o garante que o ShadowCom atenda aos mais altos padr√µes de seguran√ßa e privacidade, protegendo usu√°rios contra uma ampla gama de amea√ßas com prote√ß√£o ativa e cont√≠nua atrav√©s do Security Watchdog.* 